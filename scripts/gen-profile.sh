#!/usr/bin/env bash
# scripts/gen-profile.sh ‚Äî build ~/.profile from modular dotfiles, safely

set -euo pipefail

# ---- locate repo & defaults ----
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

TARGET_PROFILE="${HOME}/.profile"
DOTFILES_DIR="${REPO_ROOT}/dotfiles"   # <-- default: repo/dotfiles

# Allow override: scripts/gen-profile.sh --dir /path/to/dotfiles
if [[ "${1:-}" == "--dir" && -n "${2:-}" ]]; then
  DOTFILES_DIR="$2"
fi

INPUT_FILES=(
  ".aliasesrc"
  ".dirrc"
  ".shell-aliases"
  ".tweak"
  ".zipping"
)

MARK_BEGIN="# >>> linux-setup managed BEGIN >>>"
MARK_END="# <<< linux-setup managed END   <<<"

log() { printf '%s\n' "$*" >&2; }

# Prelude: load logging helpers early + safe fallbacks
build_prelude() {
  cat <<'EOF'
# --- linux-setup prelude (autogenerated) ---
# Load logging helpers early so downstream code can use info/warning/error
if [ -r "$HOME/linux-setup/scripts/print_messages.sh" ]; then
  . "$HOME/linux-setup/scripts/print_messages.sh"
elif [ -r "$HOME/.setup/scripts/print_messages.sh" ]; then
  . "$HOME/.setup/scripts/print_messages.sh"
fi
# Define fallbacks if functions are still unknown (avoid calling /usr/bin/info)
type info    >/dev/null 2>&1 || info()    { printf '‚Ñπ %s\n' "$*"; }
type warning >/dev/null 2>&1 || warning() { printf '‚ö† %s\n' "$*"; }
type error   >/dev/null 2>&1 || error()   { printf '‚úò %s\n' "$*"; }
# Backward-compat: some old snippets use 'warn'
type warn    >/dev/null 2>&1 || warn()    { warning "$@"; }
# --- end prelude ---
EOF
}

# Build managed block to a temp file
# Writes ONLY the numeric count to stdout; logs to stderr.
build_managed_block() {
  local tmp="$1"
  : > "$tmp"
  build_prelude >> "$tmp"
  printf '\n' >> "$tmp"

  local found=0
  for file in "${INPUT_FILES[@]}"; do
    local full="${DOTFILES_DIR}/${file}"
    if [[ -f "$full" ]]; then
      log "  ‚úÖ Including $full"
      {
        printf '\n# --- %s/%s ---\n' "$DOTFILES_DIR" "$file"
        cat "$full"
        printf '\n'
      } >> "$tmp"
      found=$((found+1))
    else
      log "  ‚ö†Ô∏è  Skipping missing file: $full"
    fi
  done
  printf '%s' "$found"
}

merge_managed_block() {
  local target="$1" managed="$2"
  if [[ -f "$target" ]]; then
    awk -v mb="$MARK_BEGIN" -v me="$MARK_END" '
      BEGIN{skip=0}
      $0 ~ mb {skip=1; next}
      $0 ~ me {skip=0; next}
      skip==0 {print}
    ' "$target" > "${target}.nomgr.tmp"
    mv "${target}.nomgr.tmp" "$target"
  else
    : > "$target"
  fi
  {
    printf '\n%s\n' "$MARK_BEGIN"
    cat "$managed"
    printf '%s\n' "$MARK_END"
  } >> "$target"
}

# ---- main ----
log "üîß Generating $TARGET_PROFILE from $DOTFILES_DIR"

if [[ -f "$TARGET_PROFILE" ]]; then
  cp -a "$TARGET_PROFILE" "${TARGET_PROFILE}.bak.$(date +%F-%H%M%S)"
  log "  üíæ Backup: ${TARGET_PROFILE}.bak.*"
fi

tmp_block="$(mktemp)"
found_count="$(build_managed_block "$tmp_block")"

if [[ "$found_count" -eq 0 ]]; then
  log "  ‚ùó No dotfiles found in $DOTFILES_DIR. Leaving existing $TARGET_PROFILE unchanged."
  rm -f "$tmp_block"
  exit 0
fi

merge_managed_block "$TARGET_PROFILE" "$tmp_block"
rm -f "$tmp_block"

log "‚úÖ Profile updated at $TARGET_PROFILE"
